# Architecture Document — Bean & Brew

**Document type:** Architecture
**Project:** Bean & Brew — Coffee Shop E-Commerce Web Application
**Version:** 1.0
**Date:** 2026-03-01
**Author:** Architect

---

## 1. System Overview

Bean & Brew is a client-server application composed of three distinct layers:

```
┌─────────────────────────────────────┐
│          Browser (React / Vite)     │  http://localhost:5173
│   SPA — React Router, Axios        │
└────────────────┬────────────────────┘
                 │  /api/*  (proxied in dev, reverse-proxied in prod)
┌────────────────▼────────────────────┐
│        Node.js / Express API        │  http://localhost:4000
│   REST, JWT auth, express-validator │
└────────────────┬────────────────────┘
                 │  pg (node-postgres)
┌────────────────▼────────────────────┐
│            PostgreSQL               │  localhost:5432 / brewedtrue
└─────────────────────────────────────┘
```

All three layers run on the same machine in development. In production, each layer can be extracted to its own host — the only coupling is the `DATABASE_URL` and `FRONTEND_URL` environment variables.

---

## 2. Technology Choices

### 2.1 Frontend — React + Vite

**Why React?**
React's component model and context API are a natural fit for the two cross-cutting concerns this app has: auth state (who is logged in?) and cart state (what is in the bag?). Both are consumed in many places across the component tree.

**Why Vite?**
Faster cold-start and HMR than Create React App. The built-in proxy configuration (`/api → http://localhost:4000`) eliminates CORS friction during development.

**React Router v6**
Provides nested route layout (Navbar wraps all pages), declarative `<Navigate>` for redirects, and `useLocation` / `useNavigate` hooks used extensively in the notification badge and redirect logic.

### 2.2 Backend — Node.js + Express

**Why Express?**
Minimal overhead and maximum flexibility. The application's routing needs are straightforward (RESTful resources, role-based middleware), so a framework with less convention overhead is a better fit than NestJS or Fastify.

**Module system:** CommonJS (`require` / `module.exports`) — consistent with the Node.js ecosystem default and avoids `.mjs` / `"type": "module"` configuration overhead.

**express-validator**
Used on every mutation route to validate and sanitise inputs before they reach the database, keeping route handlers clean and reducing XSS / injection risk.

### 2.3 Database — PostgreSQL

**Why PostgreSQL?**
The checkout requires an atomic transaction with row-level locking (`SELECT … FOR UPDATE`) to prevent overselling. PostgreSQL's ACID guarantees and first-class transaction support make this straightforward. SQLite lacks row-level locking; MySQL would also work but PostgreSQL's UUID support (`gen_random_uuid()` via pgcrypto) and rich type system were preferred.

**UUID primary keys**
All primary keys are UUIDs generated by PostgreSQL's `gen_random_uuid()`. This avoids exposing sequential integer IDs in URLs (which would reveal order volume), eliminates merge conflicts in multi-node future scenarios, and is consistent across all tables.

**Prices in cents**
All monetary values are stored and computed as integers (e.g. `$14.99` → `1499`). Floating-point arithmetic on currency is a known source of rounding bugs. Integer cent arithmetic is exact.

### 2.4 Authentication — JWT + Refresh Token Rotation

See Section 4 for full detail. The key design choices:
- Short-lived access tokens (15 min) stored **in memory only** (`window.__accessToken`) — never in `localStorage` or a cookie. This eliminates XSS token theft.
- Long-lived refresh tokens (7 days) stored in an **httpOnly, sameSite=strict cookie** — inaccessible to JavaScript, preventing XSS; `sameSite=strict` mitigates CSRF.
- **Rotation on every refresh** — the old token is deleted from the DB and a new one issued, enabling token invalidation on logout.

---

## 3. Database Schema

```sql
-- Users
users (
  id            UUID PK DEFAULT gen_random_uuid(),
  email         VARCHAR(255) UNIQUE NOT NULL,
  password_hash VARCHAR(255) NOT NULL,
  role          VARCHAR(10) NOT NULL DEFAULT 'client'  -- CHECK ('admin','client')
  created_at    TIMESTAMPTZ NOT NULL DEFAULT NOW()
)

-- Products
products (
  id            UUID PK,
  name          VARCHAR(255) NOT NULL,
  price_cents   INTEGER NOT NULL CHECK (> 0),
  weight_grams  INTEGER NOT NULL CHECK (> 0),
  quantity      INTEGER NOT NULL DEFAULT 0 CHECK (>= 0),
  image_url     TEXT NOT NULL,
  created_at    TIMESTAMPTZ,
  updated_at    TIMESTAMPTZ
)

-- Orders
orders (
  id                UUID PK,
  user_id           UUID REFERENCES users(id),       -- nullable for guest orders
  is_guest          BOOLEAN NOT NULL DEFAULT FALSE,
  customer_name     VARCHAR(255) NOT NULL,
  customer_surname  VARCHAR(255) NOT NULL,
  delivery_address  TEXT NOT NULL,
  phone             VARCHAR(50) NOT NULL,
  promo_code        VARCHAR(50),
  discount_cents    INTEGER NOT NULL DEFAULT 0,
  subtotal_cents    INTEGER NOT NULL,
  total_cents       INTEGER NOT NULL,
  payment_method    VARCHAR(10) NOT NULL              -- CHECK ('cash','card')
  is_read           BOOLEAN NOT NULL DEFAULT FALSE,
  created_at        TIMESTAMPTZ
)

-- Order Items (immutable snapshot)
order_items (
  id                        UUID PK,
  order_id                  UUID NOT NULL REFERENCES orders(id),
  product_id                UUID REFERENCES products(id) ON DELETE SET NULL,
  product_name_snapshot     VARCHAR(255) NOT NULL,
  unit_price_cents_snapshot INTEGER NOT NULL,
  weight_grams_snapshot     INTEGER NOT NULL,
  quantity                  INTEGER NOT NULL CHECK (>= 1)
)

-- Refresh Tokens
refresh_tokens (
  id         UUID PK,
  user_id    UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  token      TEXT NOT NULL,
  expires_at TIMESTAMPTZ NOT NULL,
  created_at TIMESTAMPTZ
)

-- Reviews
reviews (
  id         UUID PK,
  user_id    UUID NOT NULL UNIQUE REFERENCES users(id) ON DELETE CASCADE,
  rating     INTEGER NOT NULL CHECK (BETWEEN 1 AND 5),
  body       TEXT NOT NULL CHECK (char_length BETWEEN 10 AND 500),
  created_at TIMESTAMPTZ,
  updated_at TIMESTAMPTZ
)

-- Contact Messages
contact_messages (
  id         UUID PK,
  name       VARCHAR(255) NOT NULL,
  email      VARCHAR(255) NOT NULL,
  subject    VARCHAR(255) NOT NULL,
  body       TEXT NOT NULL,
  is_read    BOOLEAN NOT NULL DEFAULT FALSE,
  reply      TEXT,
  replied_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ
)
```

**Indexes:**
- `idx_orders_user_id` — frequent filter on `orders.user_id` for client order history
- `idx_order_items_order_id` — frequent join when fetching order detail
- `idx_refresh_tokens_user_id` — token lookup on login/refresh

---

## 4. Authentication Flow

### 4.1 Login / Register

```
Client                        Express                      PostgreSQL
  │── POST /api/auth/login ──▶│                              │
  │                            │── SELECT user by email ────▶│
  │                            │◀─ user row ─────────────────│
  │                            │   bcrypt.compare()
  │                            │── INSERT refresh_token ─────▶│
  │                            │◀─ OK ───────────────────────│
  │◀── { accessToken } ────────│
  │    + Set-Cookie: refresh_token (httpOnly)
  │
  │  window.__accessToken = accessToken  (in-memory only)
```

### 4.2 Authenticated Request

```
Client                        Express
  │── GET /api/orders/mine ──▶│
  │   Authorization: Bearer <accessToken>
  │                            │  jwt.verify(token, JWT_SECRET)
  │                            │  req.user = { id, email, role }
  │◀── 200 { orders } ─────────│
```

### 4.3 Token Refresh (on 401 or app load)

```
Client (api.js interceptor)   Express                       PostgreSQL
  │── POST /api/auth/refresh ─▶│
  │   Cookie: refresh_token    │── SELECT refresh_token ───▶│
  │                            │◀─ token row ────────────────│
  │                            │   jwt.verify(token, JWT_REFRESH_SECRET)
  │                            │── DELETE old token ─────────▶│
  │                            │── INSERT new token ─────────▶│
  │◀── { accessToken } ────────│
  │    + Set-Cookie: refresh_token (new, httpOnly)
```

### 4.4 Axios Interceptor (frontend/src/api.js)

The shared Axios instance:
1. Attaches `Authorization: Bearer <window.__accessToken>` to every request.
2. On a `401` response, automatically calls `POST /api/auth/refresh` once.
3. If refresh succeeds, retries the original request with the new token.
4. If refresh fails (expired/invalid cookie), clears user state and redirects to login.

This means individual components never handle token lifecycle — they just call `api.get(...)`.

---

## 5. Frontend Architecture

### 5.1 State Management

No third-party state library (Redux, Zustand) is used. Two React Contexts cover all shared state:

| Context | Purpose | Persistence |
|---|---|---|
| `AuthContext` | Current user, `isGuest` flag, login/logout/register/enterAsGuest/exitGuest | In-memory (`window.__accessToken`); guest flag in `sessionStorage` |
| `BagContext` | Cart items (productId + quantity) | `localStorage` — survives page refresh and guest sessions |

All other state is local to the page component that owns it.

### 5.2 Routing

```
/                    → HomePage        (public, client, guest, admin)
/login               → LoginPage       (public)
/register            → RegisterPage    (public)
/contact             → ContactPage     (public, client)
/shop                → ShopPage        (client, guest)  ← allowGuest
/bag                 → BagPage         (client, guest)  ← allowGuest
/checkout            → CheckoutPage    (client, guest)  ← allowGuest
/history             → HistoryPage     (client)
/messages            → MyMessagesPage  (client)
/admin               → AdminPage       (admin)
/admin/orders        → AdminOrdersPage (admin)
/admin/messages      → AdminMessagesPage (admin)
* → redirect to /
```

`ProtectedRoute` wraps every guarded route. It reads `{ user, loading, isGuest }` from `AuthContext` and either renders children or navigates away. The `allowGuest` prop enables guest access to `/shop`, `/bag`, and `/checkout`.

### 5.3 Notification Badge Architecture

Admin badges (unread messages, unread orders) and client badges (unseen replies) are polled every 60 seconds from the Navbar component.

**Admin badges** use server-side `is_read` fields:
- `GET /api/contact/admin/unread-count` → count of `contact_messages WHERE is_read = FALSE`
- `GET /api/orders/admin/unread-count` → count of `orders WHERE is_read = FALSE`
- Opening a message/order triggers a server-side update (`is_read = TRUE`), making the state authoritative and shared across browser sessions.

**Client reply badges** use a localStorage-based seen-set:
- `GET /api/contact/mine/replied-ids` → UUIDs of the user's messages that have a reply
- Frontend diffs against `seenReplyIds_{userId}` stored in `localStorage`
- The seen-set is written **only on explicit click** (opening a message). It is never written inside a `useEffect` — this avoids React StrictMode's double-invocation causing all replies to be immediately marked as seen.

### 5.4 Key Frontend Patterns

**Never write localStorage in `useEffect`**
React 18 StrictMode invokes effects twice in development. Any `localStorage.setItem` inside a `useEffect` would be read by the second invocation, causing "new reply" state to be immediately cleared. All localStorage writes happen in user-interaction handlers (click callbacks).

**Server-side read state for admin, localStorage for client replies**
Admin unread state (messages, orders) is authoritative on the server — opening a record marks it read via a DB update. This means the state is correct even if the admin uses multiple devices. Client reply badges use localStorage because the server has no concept of "which replies this client has personally viewed" without adding per-user-per-message read tracking.

---

## 6. Backend Architecture

### 6.1 Directory Structure

```
backend/src/
├── db/
│   ├── index.js      — pg Pool singleton + query helper + getClient()
│   ├── schema.sql    — DDL (idempotent: CREATE IF NOT EXISTS + ALTER … IF NOT EXISTS)
│   └── seed.js       — runs schema.sql then inserts admin + sample products
├── middleware/
│   └── auth.js       — authenticate() + requireAdmin()
├── routes/
│   ├── auth.js       — /api/auth/*
│   ├── products.js   — /api/products/*
│   ├── orders.js     — /api/orders/*
│   ├── contact.js    — /api/contact/*
│   └── reviews.js    — /api/reviews/*
└── index.js          — Express app wiring, CORS, cookie-parser, route mounting
```

### 6.2 Route Ordering Convention

Express matches routes in declaration order. Named sub-routes (e.g. `/admin/unread-count`, `/mine/replied-ids`) must be declared **before** parameterised routes (e.g. `/admin/:id`, `/mine/:orderId`) to prevent the parameter from consuming the literal path segment.

```js
// Correct order in orders.js:
router.get('/admin/unread-count', ...)   // named first
router.get('/admin/:id', ...)            // wildcard second
```

### 6.3 Checkout Transaction

```
BEGIN
  SELECT products WHERE id IN (...) FOR UPDATE   ← row lock
  validate stock for each item
  if any insufficient: ROLLBACK, return 409
  calculate subtotal, discount, total  (server-side, never trust client)
  INSERT orders (user_id | NULL, is_guest, ...)
  for each item:
    INSERT order_items (snapshot name, price, weight)
    UPDATE products SET quantity = quantity - n
COMMIT
```

The `FOR UPDATE` lock prevents two concurrent requests from both reading "1 unit in stock" and both succeeding. Only one will commit; the other will block until the first commits, then see `quantity = 0` and return 409.

### 6.4 Guest Order Route

`POST /api/orders/guest` shares its core logic with `POST /api/orders` via the `placeOrderTransaction` helper function. The only differences:
- No `authenticate` middleware.
- `userId = null`, `isGuest = true` passed to the helper.
- `orders.user_id` is nullable to accommodate this.

---

## 7. Security Considerations

| Threat | Mitigation |
|---|---|
| XSS token theft | Access token in memory (`window.__accessToken`), never in `localStorage` or a readable cookie |
| CSRF | Refresh token cookie is `sameSite=strict`; mutation endpoints require a Bearer token (not a cookie) |
| Password exposure | bcrypt with 12 rounds; plaintext never logged or stored |
| SQL injection | All queries use parameterised `$1, $2, ...` placeholders via `node-postgres` |
| Privilege escalation | Every admin route has both `authenticate` and `requireAdmin` middleware; role checked on the server, never trusted from the client |
| Overselling | Checkout uses `SELECT … FOR UPDATE` + a single transaction; stock cannot go below 0 (DB `CHECK` constraint) |
| Price manipulation | Totals are recalculated on the server using DB prices; client-submitted amounts are ignored |
| Input validation | `express-validator` validates and sanitises all inputs on mutation routes |

---

## 8. Deployment Notes

### Environment Variables (backend/.env)

| Variable | Description |
|---|---|
| `DATABASE_URL` | PostgreSQL connection string |
| `JWT_SECRET` | Secret for signing access tokens (keep strong, rotate periodically) |
| `JWT_REFRESH_SECRET` | Separate secret for refresh tokens |
| `PORT` | API port (default 4000) |
| `NODE_ENV` | `development` / `production` (controls cookie `secure` flag) |
| `FRONTEND_URL` | Allowed CORS origin in production |

### Vite Proxy vs Production

In development, Vite proxies `/api/*` to `http://localhost:4000`. In production:
- Build the frontend: `npm run build` → `frontend/dist/`
- Serve `dist/` with nginx or a CDN.
- Configure nginx to proxy `/api/` to the Node.js process.
- Set `FRONTEND_URL` in the backend `.env` to the deployed frontend origin for CORS.

### Database Migrations

Schema changes are applied as `ALTER TABLE … IF NOT EXISTS` statements appended to `schema.sql`. Running `npm run seed` re-applies the entire file idempotently, so it is safe to run on an existing database. Destructive migrations (column drops, type changes) should be scripted separately and run manually.
